#import "iostream.bah"
#import "string.bah"
#import "path.bah"
#import "exec.bah"

globalID int*

#include "lexer.bah"    //Bah compiler's lexer
#include "colors.bah"   //syntax highlighting
#include "terminal.bah" //terminal handling
#include "bindings.bah" // lib dl bindings

cmdRaw = []char //current command buffer
currStr = string("")
multiLine = false
currentFile = []cpstring //for saving
currentFileName = ""

#include "io.bah" //io operations (compiling)
#include "parser.bah"    //Bah compiler's lexer

main(args []cpstring) int {

    mkdir("./tmp", 0777)

    nbEncls = 0

    i=0
    
    globalID = &i

    for 1==1, i++ {
        info = "... > "
        if multiLine == false {
            isFuncDecl = false
            info = "$"+intToStr(i)+" > "
        }
        
        cmd = string(getInputLine(info))

        j=0; for j < cmd.length, j++ {
            if cmd.charAt(j) == '{' || cmd.charAt(j) == '(' || cmd.charAt(j) == '[' {
                nbEncls++
            } else if cmd.charAt(j) == '}' || cmd.charAt(j) == ')' || cmd.charAt(j) == ']' {
                nbEncls--
            }
        }

        if nbEncls > 0 {
            i--
            multiLine = true
            currStr.append(cmd.str()+"\n")
            continue
        } else if multiLine == true {
            nbEncls = 0
            cmd.prepend(currStr.str())
            currStr.set("")
            multiLine = false
        }
        
        if cmd.str() == ".q" || cmd.str() == ".quit" {
            break
        }

        currentFile[len(currentFile)] = cmd.str()

        parseCmd(&cmd, i)

    }

    garbageFiles = listFiles("./tmp")
    i=0; for i < len(garbageFiles), i++ {
        removeFile("./tmp/"+garbageFiles[i])
    }

    println("Good bye!")



    return 0
}